CREATE OR REPLACE PACKAGE BODY "TEST_VSTSRedgate"."PKGGLOBALMETHODS" IS





FUNCTION FNCSPLITALPHA
        (   INPUTSTRING IN VARCHAR2,
            STRINGPART IN OUT NOCOPY VARCHAR2)
    RETURN NUMBER

    IS
    NUMERROR NUMBER;
    NUMCOUNT NUMBER(2);
    NUMSUB NUMBER(2);
    NUMNUMBER NUMBER(10);
    VARALPHA VARCHAR2(5);
    VARERROR VARCHAR2(512);
BEGIN
    NUMNUMBER := 0;
    NUMCOUNT := 0;

    NUMERROR := 1;
    VARERROR := 'Checking for length of alpha';
    FOR NUMSUB IN 1 .. LENGTH(INPUTSTRING)
    LOOP
        IF ASCII(SUBSTR(INPUTSTRING, NUMSUB, 1)) IN (48,49,50,51,52,53,54,55,56,57) THEN
            EXIT;
        END IF;

        NUMCOUNT := NUMCOUNT + 1;
    END LOOP;

    VARALPHA := NVL(SUBSTR(INPUTSTRING, 1, NUMCOUNT),'');
    NUMNUMBER := TO_NUMBER(SUBSTR(INPUTSTRING, NUMCOUNT + 1));

    STRINGPART := VARALPHA;
    RETURN NUMNUMBER;

EXCEPTION
    WHEN OTHERS THEN
        
        NUMNUMBER := 0;
        RETURN NUMNUMBER;
END;
FUNCTION FNCRETURNERROR
      (   PROCNAME IN VARCHAR2,
          PROCMESSAGE IN VARCHAR2,
          RECORDSETS IN NUMBER,
          ERRORNUMBER IN NUMBER,
          OPERATIONMESSAGE IN VARCHAR2,
          SYSMESSAGE IN VARCHAR2)
    RETURN VARCHAR2
    IS

    VARERROR VARCHAR2(4000);
BEGIN
   SELECT XMLELEMENT("ErrorData",
        XMLFOREST(PROCNAME AS "Process",
            PROCMESSAGE AS "ProcessMessage",
            RECORDSETS AS "RecordSets",
            OPERATIONMESSAGE AS "Operation",
            ERRORNUMBER AS "Error",
            SYSMESSAGE AS "Message")).GETSTRINGVAL()
        INTO VARERROR
        FROM DUAL;

    RETURN VARERROR;
EXCEPTION
    WHEN OTHERS THEN
      VARERROR := 'Error: ' || SQLERRM;
      RAISE_APPLICATION_ERROR(-20101, VARERROR);
      RETURN NULL;
END;

FUNCTION FNCRETURNERROR
    (   FUNCNAME IN VARCHAR2,
        ERRORNUMBER IN NUMBER,
        FUNCMESSAGE IN VARCHAR2,
        OPERATIONMESSAGE IN VARCHAR2,
        SYSMESSAGE IN VARCHAR2)
    RETURN VARCHAR2
    IS
    VARERROR VARCHAR2(4000);
BEGIN

    VARERROR := 'Function:(' || FUNCNAME || ') - ';
    VARERROR := VARERROR || ' Msg: ' || FUNCMESSAGE;
    VARERROR := VARERROR || ' Op: ' || OPERATIONMESSAGE;
    VARERROR := VARERROR || ' Error: ' || ERRORNUMBER;
    VARERROR := VARERROR || ' = ' || SYSMESSAGE;

    RETURN VARERROR;

EXCEPTION
  WHEN OTHERS THEN
    VARERROR := SQLERRM;
    RAISE_APPLICATION_ERROR(-20101, VARERROR);
    RETURN NULL;
END;

FUNCTION FNCRETURNSTATUS
    (   INPUTSTATUS IN NUMBER,
        ACTIONCODE IN NUMBER)
        RETURN NUMBER
    IS

    NUMERROR            NUMBER;
    NUMSTATUS           NUMBER(8);
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    STATUS_ERROR        EXCEPTION;
    BEGIN
    NUMSTATUS := 0;
    VARMESSAGE := 'Status : ' || INPUTSTATUS || ' Action: ' || ACTIONCODE;
    VAROPERATION := 'Converting Status';

    IF ACTIONCODE = GCONST.ADDSAVE THEN
      IF  INPUTSTATUS = GCONST.STATUSAUTHORIZED THEN
        NUMSTATUS := GCONST.STATUSL2ENTRY;
      ELSIF INPUTSTATUS IN (GCONST.STATUSL2CONFIRMED, GCONST.STATUSL3CONFIRMED) THEN
        NUMSTATUS := NUMSTATUS + 7;
      ELSE
        RAISE STATUS_ERROR;
      END IF;
    ELSIF ACTIONCODE IN (GCONST.EDITSAVE,GCONST.DELETESAVE,GCONST.CONFIRMSAVE) THEN
      IF INPUTSTATUS IN (GCONST.STATUSL2ENTRY, GCONST.STATUSL2UPDATED,
            GCONST.STATUSL3ENTRY, GCONST.STATUSL3UPDATED,
            GCONST.STATUSL4ENTRY, GCONST.STATUSL4UPDATED) THEN

        IF ACTIONCODE =  GCONST.EDITSAVE THEN
          NUMSTATUS := TO_NUMBER(SUBSTR(TO_CHAR(INPUTSTATUS),1,7) || '2');
        ELSIF ACTIONCODE =  GCONST.DELETESAVE THEN
          NUMSTATUS := TO_NUMBER(SUBSTR(TO_CHAR(INPUTSTATUS),1,7) || '3');
        ELSIF ACTIONCODE = GCONST.CONFIRMSAVE THEN
          NUMSTATUS := TO_NUMBER(SUBSTR(TO_CHAR(INPUTSTATUS),1,7) || '4');
        END IF;

      ELSE
          RAISE STATUS_ERROR;
      END IF;
    ELSE
      RAISE STATUS_ERROR;
    END IF;

    RETURN NUMSTATUS;
EXCEPTION
    WHEN STATUS_ERROR THEN
      VARERROR := VARMESSAGE || ' - Action and Status mismatch';
      RAISE_APPLICATION_ERROR(-20101, VARERROR);
      RETURN NUMSTATUS;
    WHEN OTHERS THEN
      VARERROR := SQLERRM;
      RAISE_APPLICATION_ERROR(-20101, VARERROR);
      RETURN NUMSTATUS;
END FNCRETURNSTATUS;

FUNCTION FNCSETNODEVALUE
    (   INPUTDOC IN OUT NOCOPY XMLDOM.DOMDOCUMENT,
        NODEPATH IN VARCHAR2,
        NODEVALUE IN VARCHAR2)
        RETURN NUMBER
    IS

    NUMERROR            NUMBER;
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    NODTEMP             XMLDOM.DOMNODE;
    NODTEMP1            XMLDOM.DOMNODE;
    TXTNODE             XMLDOM.DOMTEXT;
    DOCTEMP             XMLDOM.DOMDOCUMENT;
    BLANK_NODE          EXCEPTION;
BEGIN
    VARMESSAGE := 'Setting Node for path: ' || NODEPATH;
    NUMERROR := 0;

    VAROPERATION := 'Extracting the node from the path';
    NODTEMP := XSLPROCESSOR.SELECTSINGLENODE(
                XMLDOM.MAKENODE(INPUTDOC), NODEPATH);

    IF XMLDOM.ISNULL(NODTEMP) THEN
      RAISE BLANK_NODE;
    END IF;

    NODTEMP1 := XMLDOM.GETFIRSTCHILD(NODTEMP);

    IF XMLDOM.ISNULL(NODTEMP1) THEN

      TXTNODE := XMLDOM.CREATETEXTNODE(INPUTDOC, NODEVALUE);
      NODTEMP1 := XMLDOM.MAKENODE(TXTNODE);
      NODTEMP1 := XMLDOM.APPENDCHILD(NODTEMP, NODTEMP1);
    ELSE
      XMLDOM.SETNODEVALUE(NODTEMP1, NODEVALUE);
    END IF;

    RETURN NUMERROR;

EXCEPTION
    WHEN BLANK_NODE THEN
      NUMERROR := -20101;
      VARERROR := 'Node: ' || NODEPATH || ' does not exist or has no value';
      VARERROR := FNCRETURNERROR('SetNode', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
      RAISE_APPLICATION_ERROR(NUMERROR, VARERROR);
      RETURN NUMERROR;
    WHEN OTHERS THEN
        NUMERROR := SQLCODE;
        VARERROR := SQLERRM;
        VARERROR := FNCRETURNERROR('SetNode(1)', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN NUMERROR;
END FNCSETNODEVALUE;

FUNCTION FNCSETNODEVALUE
    (   DOCNODE IN OUT NOCOPY XMLDOM.DOMNODE,
        INPUTNODE IN OUT NOCOPY XMLDOM.DOMNODE,
        NODEVALUE IN VARCHAR2)
        RETURN NUMBER
    IS

    NUMERROR            NUMBER;
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    NODTEMP             XMLDOM.DOMNODE;
    NODTEMP1            XMLDOM.DOMNODE;
    TXTNODE             XMLDOM.DOMTEXT;
    DOCTEMP             XMLDOM.DOMDOCUMENT;
 BEGIN
    VARMESSAGE := 'Setting value for the Node';
    NUMERROR := 0;

    NODTEMP1 := XMLDOM.GETFIRSTCHILD(INPUTNODE);

    IF XMLDOM.ISNULL(NODTEMP1) THEN
      DOCTEMP := XMLDOM.MAKEDOCUMENT(DOCNODE);
      TXTNODE := XMLDOM.CREATETEXTNODE(DOCTEMP, NODEVALUE);
      NODTEMP1 := XMLDOM.MAKENODE(TXTNODE);
      NODTEMP1 := XMLDOM.APPENDCHILD(INPUTNODE, NODTEMP1);
    ELSE
      XMLDOM.SETNODEVALUE(NODTEMP1, NODEVALUE);
    END IF;

    RETURN NUMERROR;

EXCEPTION
    WHEN OTHERS THEN
        NUMERROR := SQLCODE;
        VARERROR := SQLERRM;
        VARERROR := FNCRETURNERROR('SetNode(2)', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN NUMERROR;
END FNCSETNODEVALUE;


FUNCTION FNCGETNODEVALUE
   (    INPUTNODE IN XMLDOM.DOMNODE,
        NODEPATH IN VARCHAR2)
        RETURN VARCHAR2

    IS

    NUMERROR            NUMBER;
    VARTEMP             VARCHAR2(2048);
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    NODTEMP             XMLDOM.DOMNODE;
    BLANK_NODE          EXCEPTION;
BEGIN
   VARMESSAGE := 'Getting Node for path: ' || NODEPATH;
    NUMERROR := 0;
    VARTEMP := '';

--insert into rtemp(TT,TT2) values ('Inside FNCGETNODEVALUE 0','welcome, INPUTNODE: '|| 'INPUTNODE');

    VAROPERATION := 'Extracting the node from the path';
    NODTEMP := XSLPROCESSOR.SELECTSINGLENODE(INPUTNODE, NODEPATH);

    IF XMLDOM.ISNULL(NODTEMP) THEN
      RAISE BLANK_NODE;
    END IF;

    NODTEMP := XMLDOM.GETFIRSTCHILD(NODTEMP);
    VARTEMP := XMLDOM.GETNODEVALUE(NODTEMP);

    RETURN VARTEMP;
EXCEPTION
    WHEN BLANK_NODE THEN
      NUMERROR := -20101;
      VARERROR := 'Node: ' || NODEPATH || ' does not exist or has no value';
      VARERROR := FNCRETURNERROR('GetNode', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
      RAISE_APPLICATION_ERROR(NUMERROR, VARERROR);
      RETURN VARTEMP;
    WHEN OTHERS THEN
        NUMERROR := SQLCODE;
        VARERROR := SQLERRM;
        VARERROR := FNCRETURNERROR('GetNode', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN VARTEMP;
END FNCGETNODEVALUE;

FUNCTION FNCADDNODE
    (   DOCDOCUMENT IN OUT NOCOPY XMLDOM.DOMDOCUMENT,
        TARGETNODE IN OUT NOCOPY XMLDOM.DOMNODE,
        NODENAME IN VARCHAR2,
        NODEVALUE IN VARCHAR2 := NULL)
        RETURN XMLDOM.DOMNODE
  IS

    NUMERROR            NUMBER;
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    ELMXML              XMLDOM.DOMELEMENT;
    NODXML              XMLDOM.DOMNODE;
    NODXML1             XMLDOM.DOMNODE;
    TXTDOM              XMLDOM.DOMTEXT;
BEGIN
    ELMXML := XMLDOM.CREATEELEMENT(DOCDOCUMENT, NODENAME);
    NODXML := XMLDOM.MAKENODE(ELMXML);
    NODXML := XMLDOM.APPENDCHILD(TARGETNODE, NODXML);
    IF NODEVALUE IS NOT NULL THEN
      TXTDOM := XMLDOM.CREATETEXTNODE(DOCDOCUMENT, NODEVALUE);
      NODXML1 := XMLDOM.MAKENODE(TXTDOM);
      NODXML := XMLDOM.APPENDCHILD(NODXML, NODXML1);
    END IF;

    RETURN NODXML;
EXCEPTION
    WHEN OTHERS THEN
        NUMERROR := SQLCODE;
        VARERROR := SQLERRM;
        VARERROR := FNCRETURNERROR('AddNode', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN NODXML;

END FNCADDNODE;


 FUNCTION FNCADDNODE
    (   DOCDOCUMENT IN OUT NOCOPY XMLDOM.DOMDOCUMENT,
        TARGETNODE IN OUT NOCOPY XMLDOM.DOMNODE,
         NODXML  IN XMLDOM.DOMNODE)
         RETURN XMLDOM.DOMNODE
  IS

    NUMERROR            NUMBER;
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    ELMXML              XMLDOM.DOMELEMENT;
    NODXML1             XMLDOM.DOMNODE;
    TXTDOM              XMLDOM.DOMTEXT;
BEGIN

      NODXML1:= NODXML;
      NODXML1 :=XMLDOM.APPENDCHILD(TARGETNODE,NODXML1);

    RETURN NODXML;
EXCEPTION
    WHEN OTHERS THEN
        NUMERROR := SQLCODE;
        VARERROR := SQLERRM;
        VARERROR := FNCRETURNERROR('AddNode', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN NODXML;

END FNCADDNODE;
FUNCTION FNCREMOVENODE
    (   DOCDOCUMENT IN OUT NOCOPY XMLDOM.DOMDOCUMENT,
        TARGETNODE IN OUT NOCOPY XMLDOM.DOMNODE,
        NODXML  IN XMLDOM.DOMNODE)
        RETURN XMLDOM.DOMNODE
  IS

    NUMERROR            NUMBER;
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    ELMXML              XMLDOM.DOMELEMENT;

    NODXML1             XMLDOM.DOMNODE;
    TXTDOM              XMLDOM.DOMTEXT;
BEGIN
     NODXML1:= NODXML;
     NODXML1:= XMLDOM.REMOVECHILD(TARGETNODE, NODXML1);
     RETURN NODXML;
EXCEPTION
    WHEN OTHERS THEN
        NUMERROR := SQLCODE;
        VARERROR := SQLERRM;
        VARERROR := FNCRETURNERROR('AddNode', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN NODXML;

END FNCREMOVENODE;

FUNCTION FNCKEYSERIAL
    (   DOCNODE IN XMLDOM.DOMNODE,
        ROWNUMBER IN NUMBER)
        RETURN NUMBER
IS

    NUMERROR            NUMBER;
    NUMFLAG             NUMBER(1);
    NUMSERIAL           NUMBER(5);
    VARFIELD            VARCHAR2(30);
    VARENTITY           VARCHAR2(30);
    VARVALUE            VARCHAR2(200);
    VARTEMP             VARCHAR2(200);
    VARXPATH            VARCHAR2(500);
    VARQUERY            VARCHAR2(4000);
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
BEGIN
    NUMSERIAL := -1;

    NUMERROR := 1;
    VAROPERATION := 'Extracting Entity Name';
    VARENTITY := FNCGETNODEVALUE(DOCNODE, '//Entity');

    VARMESSAGE := 'Generating Serial Number for: ' || VARENTITY;

    NUMERROR := 2;
    VAROPERATION := 'Selecting Field for incrementing number';
    SELECT FLDP_COLUMN_NAME
      INTO VARFIELD
      FROM TRSYSTEM999
      WHERE FLDP_TABLE_SYNONYM = VARENTITY
      AND FLDP_ADD_ACTION = GCONST.SYSINCREMENTKEY;

    VARQUERY := 'Select NVL(max(' || VARFIELD || '),0) from ' || VARENTITY || ' where ';
    NUMERROR := 3;
    VAROPERATION := 'Extracting Key Fields and building query';
    IF  ROWNUMBER IS NOT NULL AND ROWNUMBER > 0 THEN
      VARTEMP := '//' || VARENTITY || '/ROW[@NUM="' || ROWNUMBER || '"]/';
    ELSE
      VARTEMP := '//' || VARENTITY || '/ROW/';
    END IF;
    NUMFLAG := 0;

    FOR CURFIELDS IN
    (SELECT FLDP_COLUMN_NAME, FLDP_DATA_TYPE
      FROM TRSYSTEM999
      WHERE FLDP_TABLE_SYNONYM = VARENTITY
      AND NVL(FLDP_KEY_NO,0) > 0
      ORDER BY FLDP_KEY_NO)
    LOOP

      IF CURFIELDS.FLDP_COLUMN_NAME != VARFIELD THEN

        IF NUMFLAG = 0 THEN
          NUMFLAG := 1;
        ELSE
          VARQUERY := VARQUERY || ' and ';
        END IF;

        VARXPATH := VARTEMP || CURFIELDS.FLDP_COLUMN_NAME;
        VARVALUE := FNCGETNODEVALUE(DOCNODE, VARXPATH);
        VARQUERY := VARQUERY || CURFIELDS.FLDP_COLUMN_NAME || ' = ';

        IF CURFIELDS.FLDP_DATA_TYPE = 'VARCHAR2' THEN
          VARQUERY := VARQUERY || '''' || VARVALUE || '''';
        ELSIF CURFIELDS.FLDP_DATA_TYPE = 'DATE' THEN
          VARQUERY := VARQUERY || 'to_date(' ||  '''' || VARVALUE || '''';
          VARQUERY := VARQUERY || ',' || '''' || 'dd/mm/yyyy' || '''' || ')';
        ELSIF CURFIELDS.FLDP_DATA_TYPE = 'NUMBER' THEN
          VARQUERY := VARQUERY || VARVALUE;
        END IF;

      END IF;

    END LOOP;

    VAROPERATION := 'Executing Dynamic query';
    DELETE FROM TEMP;
    INSERT INTO TEMP VALUES(VARQUERY,NUMSERIAL);COMMIT;
    EXECUTE IMMEDIATE VARQUERY INTO NUMSERIAL;
    NUMSERIAL := NUMSERIAL + 1;
    RETURN NUMSERIAL;
EXCEPTION
    WHEN OTHERS THEN
        NUMERROR := SQLCODE;
        VARERROR := SQLERRM;
        VARERROR := FNCRETURNERROR('KeySerial', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN NUMSERIAL;
END FNCKEYSERIAL;

FUNCTION FNCSETPARAM(DOCXML IN OUT NOCOPY XMLDOM.DOMDOCUMENT, NODENAME IN VARCHAR2, NODEVALUE IN VARCHAR2)
  RETURN NUMBER

IS
    NOLXML XMLDOM.DOMNODELIST;
    NODXML XMLDOM.DOMNODE;
    NODXML1 XMLDOM.DOMNODE;
    TXTDOM XMLDOM.DOMTEXT;
    VARNODEVALUE VARCHAR2(4000);
    VARERROR VARCHAR2(2048);
    NUMLENGTH NUMBER(3);
    NUMSUB NUMBER(3);
    NUMRETURN NUMBER(1);
    INVALID_PARAM EXCEPTION;
BEGIN
    NUMRETURN := 0;
    VARNODEVALUE := TRIM(TO_CHAR(NODEVALUE));
 	NOLXML := XMLDOM.GETELEMENTSBYTAGNAME(DOCXML,  NODENAME);
    NUMLENGTH := XMLDOM.GETLENGTH(NOLXML);

    VARERROR := 'Getting the elements';
 	IF  NUMLENGTH = 0 THEN
        NUMRETURN := 1;


    ELSE
        FOR NUMSUB IN 0 .. NUMLENGTH - 1
        LOOP
    		NODXML := XMLDOM.ITEM(NOLXML,NUMSUB);
		    NODXML := XMLDOM.GETFIRSTCHILD(NODXML);

            IF XMLDOM.ISNULL(NODXML) = TRUE  THEN
                TXTDOM := XMLDOM.CREATETEXTNODE(DOCXML, VARNODEVALUE);
                NODXML1 := XMLDOM.MAKENODE(TXTDOM);
                NODXML := XMLDOM.ITEM(NOLXML, 0);
                NODXML := XMLDOM.APPENDCHILD(NODXML, NODXML1);
            ELSE
                XMLDOM.SETNODEVALUE(NODXML, VARNODEVALUE);
            END IF;

        END LOOP;

    END IF;

    IF NUMRETURN = 1 THEN
        RAISE INVALID_PARAM;
    END IF;

  RETURN(NUMRETURN);
EXCEPTION
  WHEN INVALID_PARAM THEN
    XMLDOM.FREEDOCUMENT(DOCXML);
    VARERROR := 'SetParam1: Unable to set value Parameter : ' || NODENAME;
    RAISE_APPLICATION_ERROR(1, VARERROR);
    NUMRETURN := 1;
    RETURN NUMRETURN;
	WHEN XMLDOM.INDEX_SIZE_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'Index Size error');
	WHEN XMLDOM.DOMSTRING_SIZE_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'String Size error');
	WHEN XMLDOM.HIERARCHY_REQUEST_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'Hierarchy request error');
	WHEN XMLDOM.WRONG_DOCUMENT_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'Wrong doc error');
	WHEN XMLDOM.INVALID_CHARACTER_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'Invalid Char error');
	WHEN XMLDOM.NO_DATA_ALLOWED_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'Nod data allowed error');
	WHEN XMLDOM.NO_MODIFICATION_ALLOWED_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'No mod allowed error');
	WHEN XMLDOM.NOT_FOUND_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'Not found error');
	WHEN XMLDOM.NOT_SUPPORTED_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'Not supported error');
	WHEN XMLDOM.INUSE_ATTRIBUTE_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'In use attr error');

  WHEN OTHERS THEN
    VARERROR := 'SetParam1: ' || NODENAME || VARERROR || ' - '  ||  SQLERRM    ;
    RAISE_APPLICATION_ERROR(-20101, VARERROR);
END;

FUNCTION FNCSETPARAM(CLBXML IN OUT NOCOPY CLOB, NODENAME IN VARCHAR2, NODEVALUE IN VARCHAR2)

    RETURN NUMBER
    IS
    NUMERROR NUMBER(1);
    DOXXML XMLDOM.DOMDOCUMENT;
BEGIN
    NUMERROR := 0;
    DOXXML := FNCRETURNDOMDOC(CLBXML);
    NUMERROR := FNCSETPARAM(DOXXML, NODENAME, NODEVALUE);
    DBMS_LOB.CREATETEMPORARY(CLBXML, TRUE);
    XMLDOM.WRITETOCLOB(DOXXML, CLBXML);
    XMLDOM.FREEDOCUMENT(DOXXML);

    RETURN NUMERROR;
END;

FUNCTION FNCSETPARAM(XMLSTRING IN OUT NOCOPY XMLTYPE,
                        NODEPATH IN VARCHAR2,
                        NODEVALUE IN VARCHAR2,
                        ADDNODE IN NUMBER := 1)
    RETURN NUMBER
    IS
    NUMERROR NUMBER(1);
    VARNODEVALUE VARCHAR2(512);
    VARERROR VARCHAR2(512);
    CLBXML CLOB;
    NODROOT XMLDOM.DOMNODE;
    NODXML XMLDOM.DOMNODE;
    NODXML1 XMLDOM.DOMNODE;
    DOXXML XMLDOM.DOMDOCUMENT;
    ELMXML XMLDOM.DOMELEMENT;
    TXTDOM XMLDOM.DOMTEXT;
    INVALID_PARAM EXCEPTION;
BEGIN
    NUMERROR := 0;
    VARNODEVALUE := TRIM(TO_CHAR(NODEVALUE));
    VARERROR := 'Converting and selecting node';
    DOXXML := FNCRETURNDOMDOC(XMLSTRING.GETCLOBVAL());
    NODROOT := XMLDOM.MAKENODE(XMLDOM.GETDOCUMENTELEMENT(DOXXML));

    IF ADDNODE = 1 THEN
        NODXML := XSLPROCESSOR.SELECTSINGLENODE(NODROOT, NODEPATH);

        IF  XMLDOM.ISNULL(NODXML) = TRUE THEN
            RAISE INVALID_PARAM;
        END IF;

    VARERROR := 'Setting node value and rewriting';
    NODXML := XMLDOM.GETFIRSTCHILD(NODXML);
    VARNODEVALUE := TRIM(TO_CHAR(NODEVALUE));
    XMLDOM.SETNODEVALUE(NODXML, VARNODEVALUE);
    ELSE
	ELMXML := XMLDOM.CREATEELEMENT(DOXXML, NODEPATH);
        NODXML := XMLDOM.MAKENODE(ELMXML);
        NODXML := XMLDOM.APPENDCHILD(NODROOT, NODXML);
        TXTDOM := XMLDOM.CREATETEXTNODE(DOXXML, VARNODEVALUE);
        NODXML1 := XMLDOM.MAKENODE(TXTDOM);
        NODXML := XMLDOM.APPENDCHILD(NODXML, NODXML1);
    END IF;

    DBMS_LOB.CREATETEMPORARY(CLBXML, TRUE);
    XMLDOM.WRITETOCLOB(DOXXML, CLBXML);
    XMLDOM.FREEDOCUMENT(DOXXML);
    XMLSTRING := XMLTYPE(CLBXML);
    RETURN NUMERROR;

EXCEPTION
    WHEN INVALID_PARAM THEN
        XMLDOM.FREEDOCUMENT(DOXXML);
        VARERROR := 'SetParam3: Unable to set value Parameter for Node : ' || NODEPATH;
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
    WHEN OTHERS THEN
        VARERROR := 'SetParam3: ' || NODEPATH || VARERROR || ' - '  ||  SQLERRM;
        RAISE_APPLICATION_ERROR(-20101, VARERROR);

END;
FUNCTION FNCPROCESSNODE
        (   DOCNODE IN OUT NOCOPY XMLDOM.DOMNODE,
            TARGETNODE IN OUT NOCOPY XMLDOM.DOMNODE,
            PROCESSTYPE IN NUMBER,
            ROWNUMBER IN NUMBER)
            RETURN NUMBER
IS

    NUMERROR            NUMBER;
    NUMTEMP             NUMBER;
    NUMCODE             NUMBER(8);
    NUMCODE1            NUMBER(8);
    NUMTEMP1            NUMBER(15);
    NUMRATE             NUMBER(15,6);
    NUMACTION           NUMBER(8);
    VARUSERID           VARCHAR2(30);
    VARREFERENCE        VARCHAR2(25);
    VARTERMINALID       VARCHAR2(30);
    VARENTITY           VARCHAR2(30);
    VARNODE             VARCHAR2(30);
    VARPROCESS          VARCHAR2(30);
    VARTEMP             VARCHAR2(2048);
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    DATTEMP             DATE;
    NODTEMP             XMLDOM.DOMNODE;
    NODTEMP1            XMLDOM.DOMNODE;
    NODROOT             XMLDOM.DOMNODE;
    NODAUDIT            XMLDOM.DOMNODE;
    NLSTEMP             XMLDOM.DOMNODELIST;
    DOCTEMP             XMLDOM.DOMDOCUMENT;
    CLBTEMP             CLOB;
    XMLTEMP             XMLTYPE;
    XMLTEMP1            XMLTYPE;
    BLANK_NODE          EXCEPTION;
BEGIN
    NUMERROR := 0;
    VARMESSAGE := 'Processing for operation: ' || PROCESSTYPE;

    IF XMLDOM.ISNULL(TARGETNODE) THEN
      RAISE BLANK_NODE;
    END IF;

    NUMERROR := 1;
    VAROPERATION := 'Extracting Node Details';
    VARNODE := XMLDOM.GETNODENAME(TARGETNODE);
    NODTEMP := XMLDOM.GETFIRSTCHILD(TARGETNODE);

    VARENTITY := FNCGETNODEVALUE(DOCNODE, '//Entity');


    VARMESSAGE := 'Processing for Action: ' || PROCESSTYPE || ' Node: ' || VARNODE;


    BEGIN
      NUMERROR := 2;
      VAROPERATION := 'Extracting Action Type';
      SELECT NVL(DECODE(PROCESSTYPE,
          GCONST.ADDSAVE, FLDP_ADD_ACTION,
          GCONST.EDITSAVE, FLDP_EDIT_ACTION,
          GCONST.DELETESAVE, FLDP_DELETE_ACTION,
          GCONST.CONFIRMSAVE, FLDP_CONFIRM_ACTION),0) AS ACTION_TYPE
        INTO NUMACTION
        FROM TRSYSTEM999
        WHERE FLDP_COLUMN_NAME = VARNODE
        AND FLDP_TABLE_SYNONYM = VARENTITY;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RETURN NUMERROR;
    END;

    IF NUMACTION = 0 THEN
      RETURN NUMERROR;
    END IF;

    NUMERROR := 3;
    VAROPERATION := 'Processing the Node';

    IF NUMACTION = SYSMOVESERIAL THEN
      VARTEMP := '1';
    ELSIF NUMACTION = SYSMOVETODAY THEN
      VARTEMP := TO_CHAR(SYSDATE, 'dd/mm/yyyy');
    ELSIF NUMACTION = SYSMOVESYSDATE THEN
      VARTEMP := TO_CHAR(SYSDATE, 'dd/mm/yyyy HH24:MI:SS');
    ELSIF NUMACTION = SYSMOVECOCODE THEN
      VARTEMP := '30199999';
    ELSIF NUMACTION = SYSENTRYCODE THEN
      VARTEMP := GCONST.STATUSENTRY;
    ELSIF NUMACTION = SYSUPDATECODE THEN
      VARTEMP := STATUSUPDATED;
    ELSIF NUMACTION = SYSDELETECODE THEN
      VARTEMP := STATUSDELETED;
    ELSIF NUMACTION = SYSCONFIRMCODE THEN
      VARTEMP := STATUSAUTHORIZED;
    ELSIF NUMACTION = SYSPRECONFIRM THEN
      VARTEMP := STATUSAPREUTHORIZATION;
    ELSIF NUMACTION = SYSUPDATESTATUS THEN
      VARTEMP := FNCRETURNSTATUS(SYSUPDATESTATUS,0);
    ELSIF NUMACTION = SYSADDSERIAL THEN
      NUMTEMP := XMLDOM.GETNODEVALUE(NODTEMP);
      NUMTEMP := NUMTEMP + 1;
      VARTEMP := NUMTEMP;
    ELSIF NUMACTION = SYSINCREMENTKEY THEN
      NUMTEMP1 := FNCKEYSERIAL(DOCNODE,ROWNUMBER);
      VARTEMP := NUMTEMP1;
    ELSIF NUMACTION = SYSPUTTIMESTAMP THEN
      SELECT TO_CHAR(SYSTIMESTAMP, 'DD-MON-YYYY HH24:MI:SS:FF3')
        INTO VARTEMP
        FROM DUAL;
    ELSIF NUMACTION = GCONST.SYSPICKPROCESS THEN
      DBMS_LOB.CREATETEMPORARY (CLBTEMP,  TRUE);
      XMLDOM.WRITETOCLOB(DOCNODE, CLBTEMP);
      PKGMASTERMAINTENANCE.PRCPROCESSPICKUP(CLBTEMP, VARNODE, VARTEMP);
    ELSIF NUMACTION IN (SYSEXPORTADJUST, SYSDEALADJUST, SYSDEALDELIVERY,
      SYSLOANCONNECT, SYSRISKGENERATE, SYSRATECALCULATE, SYSHEDGERISK,
      SYSVOUCHERCA,SYSCOMMDEALREVERSAL,SYSBCRCONNECT,SYSBCRFDLIEN) THEN
      NODTEMP1 := XMLDOM.GETFIRSTCHILD(TARGETNODE);
      VARTEMP := XMLDOM.GETNODEVALUE(NODTEMP1);
   ELSIF NUMACTION = GCONST.SYSDEALNUMBER THEN
       NUMCODE1 := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//DEAL_COMPANY_CODE'));
--       VARTEMP := PKGRETURNCURSOR.FNCGETDESCRIPTION(NUMCODE1,PICKUPSHORT) || '/FWD/';
--       VARTEMP := VARTEMP || FNCGENERATESERIAL(SERIALDEAL, NUMCODE1);
       VARTEMP := 'FWD' || FNCGENERATESERIAL(SERIALDEAL, NUMCODE1);
    ELSIF NUMACTION = GCONST.SYSTRADENUMBER THEN
      NUMCODE := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//TRAD_COMPANY_CODE'));
--      VARTEMP := PKGRETURNCURSOR.FNCGETDESCRIPTION(NUMCODE, PICKUPSHORT) || '/';
--      NUMCODE1 := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//TRAD_IMPORT_EXPORT'));
--      VARTEMP := VARTEMP || PKGRETURNCURSOR.FNCGETDESCRIPTION(NUMCODE1, PICKUPSHORT) || '/';
      VARTEMP := 'EXP' || FNCGENERATESERIAL(SERIALTRADE, NUMCODE); 
    ELSIF NUMACTION = GCONST.SYSLOANNUMBER THEN

      NUMCODE := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//FCLN_COMPANY_CODE'));
--      VARTEMP := PKGRETURNCURSOR.FNCGETDESCRIPTION(NUMCODE, PICKUPSHORT) || '/';
--      NUMCODE := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//FCLN_LOAN_TYPE'));
--      VARTEMP := VARTEMP || PKGRETURNCURSOR.FNCGETDESCRIPTION(NUMCODE, PICKUPSHORT) || '/';
      VARTEMP := 'LOAN' || FNCGENERATESERIAL(SERIALLOAN);
    ELSIF NUMACTION = GCONST.SYSRISKNUMBER THEN
      NUMCODE := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//RISK_RISK_TYPE'));
     -- VARTEMP := PKGRETURNCURSOR.FNCGETDESCRIPTION(NUMCODE,PICKUPSHORT);
      VARTEMP := 'RISK' || FNCGENERATESERIAL(SERIALRISK);
    ELSIF NUMACTION = GCONST.SYSVOUCHERNUMBER THEN
      VARTEMP := 'CA' || FNCGENERATESERIAL(SERIALCURRENT);
          ELSIF NUMACTION=GCONST.SYSSTRESSANALYSIS THEN
      VARTEMP:='SRE' || FNCGENERATESERIAL(SERIALSTRESS);
    ELSIF NUMACTION =GCONST.SYSDYNAMICREPORTID THEN
      VARTEMP := 'REP' || FNCGENERATESERIAL(SERIALDYNAMICREPORT);
    ELSIF NUMACTION =GCONST.SYSCONTRACTUPLOAD THEN
      VARTEMP := 'EXL' || FNCGENERATESERIAL(SERIALCONTRACTSCHEDULE);  
    ELSIF NUMACTION = GCONST.SYSMMDEALNUMBER THEN
--      NUMCODE := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//MDEL_TRANSACTION_TYPE'));
--      VARTEMP := PKGRETURNCURSOR.FNCGETDESCRIPTION(NUMCODE,PICKUPSHORT);
      VARTEMP := 'MM' || FNCGENERATESERIAL(SERIALMMDEAL);
      --FORWARD ROLLOVER
   ELSIF NUMACTION = GCONST.SYSFORWARDROLLOVER THEN
         VARTEMP:= 'FWDROLL' || FNCGENERATESERIAL(SERIALFORWARDROLLOVER);
   ELSIF NUMACTION  = SYSFDNUMBER THEN
      VARTEMP := 'FD' || FNCGENERATESERIAL(SERIALFD,NUMCODE1);
   elsif numAction =GConst.SYSFXGO then
      varTemp := 'FX' || fncGenerateSerial(SERIALFXGO);
    ELSIF NUMACTION = SYSBCRNUMBER THEN
    
--      SELECT FLDP_COLUMN_NAME
--        INTO VARTEMP
--        FROM TRSYSTEM999
--        WHERE FLDP_XML_FIELD = 'CompanyCode' 
--        AND FLDP_TABLE_SYNONYM = VARENTITY;
--      VARTEMP := FNCGETNODEVALUE(DOCNODE, '//' || VARTEMP);
--      VARTEMP := PKGRETURNCURSOR.FNCGETDESCRIPTION(TO_NUMBER(VARTEMP),PICKUPSHORT);
      VARTEMP := 'BCR' || FNCGENERATESERIAL(SERIALBCR);    
    ELSIF NUMACTION = GCONST.SYSCOMMDITYDEAL THEN

--       NUMCODE := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//CMDL_EXCHANGE_CODE'));
--       NUMCODE1 := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//CMDL_COMPANY_CODE'));
--       VARTEMP := PKGRETURNCURSOR.FNCGETDESCRIPTION(NUMCODE1,PICKUPSHORT);
--       NUMCODE := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//CMDL_HEDGE_TRADE'));
--       NUMTEMP := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//CMDL_BUY_SELL'));
--
--          IF NUMCODE = HEDGEDEAL THEN
--            VARTEMP := VARTEMP ||  '/HDG';
--          ELSE
--            VARTEMP := VARTEMP || '/TRD';
--          END IF;
--       
--          IF NUMTEMP =PURCHASEDEAL THEN
--            VARTEMP := VARTEMP ||  'B/';
--          ELSE
--            VARTEMP := VARTEMP ||  'S/';
--          END IF;
     VARTEMP := 'COM' || FNCGENERATESERIAL(SERIALCOMMODITYDEAL);
   ELSIF NUMACTION = GCONST.SYSCOMMRISKNUMBER THEN
--      NUMCODE := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//CRSK_CRSK_TYPE'));
--      VARTEMP := PKGRETURNCURSOR.FNCGETDESCRIPTION(NUMCODE,PICKUPSHORT);
      VARTEMP := 'RISK/' || VARTEMP || FNCGENERATESERIAL(SERIALCOMMRISK);
   ELSIF NUMACTION = GCONST.SYSFUTURETRADEDEAL THEN
       NUMCODE1 := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//CFUT_COMPANY_CODE'));
--       VARTEMP := PKGRETURNCURSOR.FNCGETDESCRIPTION(NUMCODE1,PICKUPSHORT) || '/FUT/';
      VARTEMP := 'FUR' || FNCGENERATESERIAL(SERIALFUTURETRADE, NUMCODE1);

    ELSIF NUMACTION = GCONST.SYSOPTIONTRADEDEAL THEN
       NUMCODE1 := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//COPT_COMPANY_CODE'));
       --VARTEMP := PKGRETURNCURSOR.FNCGETDESCRIPTION(NUMCODE1,PICKUPSHORT) || '/OPT/';
      VARTEMP := 'OPT' || FNCGENERATESERIAL(SERIALOPTIONTRADE, NUMCODE1);
   ELSIF NUMACTION =GCONST.SYSLINKBATCHNO THEN
      VAROPERATION :=' Generating Batch Link no';
      VARTEMP:= 'Link' || FNCGENERATESERIAL(SERIALLINKBATCHNO);
   ELSIF NUMACTION = GCONST.SYSREMITTANCENUMBER THEN
        NUMCODE1 := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//REMT_REMITTANCE_TYPE'));
--        IF NUMCODE1 = 33900001 THEN
--        VARTEMP := 'BCCL/IRMT/';
--        ELSE
--        VARTEMP := 'BCCL/ORMT/';
--        END IF;
--        NUMCODE1 := TO_NUMBER(FNCGETNODEVALUE(DOCNODE, '//REMT_LOCAL_BANK'));
--        VARTEMP := VARTEMP || PKGRETURNCURSOR.FNCGETDESCRIPTION(NUMCODE1,PICKUPSHORT) || '/';
        VARTEMP := 'REMI' || FNCGENERATESERIAL(SERIALREMITTANCE);
   ELSIF NUMACTION =GCONST.SYSREMINDERID THEN
      VARTEMP := 'REP' || FNCGENERATESERIAL(SERIALREMINDER);
    ELSIF NUMACTION = GCONST.SYSMUTUALFUNDREFERENCE THEN
      VARTEMP := 'MFIN' || FNCGENERATESERIAL(SERIALMUTUALFUND);
   ELSIF NUMACTION = GCONST.SYSMUTUALFUNDREDEMPTOIN THEN
      VARTEMP := 'MFRD' || FNCGENERATESERIAL(SERIALMUTUALFUNDREDEMPTION);
   ELSIF NUMACTION = GCONST.SYSFRANUMBER THEN
      VARTEMP := 'IFRA' || FNCGENERATESERIAL(SERIALFRANUMBER);
   ELSIF NUMACTION = GCONST.SYSIRSNUMBER THEN
      VARTEMP := 'IRS' || FNCGENERATESERIAL(SERIALIRSNUMBER); 
--   ELSIF NUMACTION = GCONST.SYSIRSNUMBER THEN
--      VARTEMP := 'IRS' || FNCGENERATESERIAL(SERIALIRSNUMBER); 
   ELSIF NUMACTION = GCONST.SYSIRFNUMBER THEN
      VARTEMP := 'IRF' || FNCGENERATESERIAL(SERIALIRFNUMBER);  
   ELSIF NUMACTION = GCONST.SYSIRONUMBER THEN
      VARTEMP := 'IRO' || FNCGENERATESERIAL(SERIALIRONUMBER);
   ELSIF NUMACTION = GCONST.SYSCCIRSNUMBER THEN
      VARTEMP := 'CCIR' || FNCGENERATESERIAL(SERIALCCIRNUMBER);  
   elsif numAction = GConst.SYSBONDDEBENTUREPURCHASE then
      varTemp := 'BDPU' || fncGenerateSerial(SERIALBONDDEBENTUREPUR);
    elsif numAction =GConst.SYSCPBDEALNUMBER THEN
      varTemp := 'CPB' || fncGenerateSerial(SERIALCPB);
   ELSIF NUMACTION =GCONST.SYSFUTURENUMBER THEN
      varTemp := 'BATCH' || fncGenerateSerial(SERIALFUTURENUMBER);
   elsif numAction=GConst.SYSEMAIL then
      varTemp := 'MAIL'||fncGenerateSerial(SERIALEMAIL);
   Elsif Numaction = SYSSCANFILES Then 
    VARTEMP := 'TRSCAN/' || fncGenerateSerial(SERIALSCANIMAGES);     
   elsif numAction = SYSBANKCHARGE then
      varTemp := fncGenerateSerial(SEARIALCHARGE);
      varTemp :='BCHA/'||varTemp;
   ELSIF NUMACTION = GCONST.SYSPICKPROCESS THEN
      DBMS_LOB.CREATETEMPORARY (CLBTEMP,  TRUE);
      XMLDOM.WRITETOCLOB(DOCNODE, CLBTEMP);
      PKGMASTERMAINTENANCE.PRCPROCESSPICKUP(CLBTEMP, VARNODE, VARTEMP);
    END IF;

    IF NUMACTION NOT IN (SYSMOVEDETAIL,SYSADDDETAIL,SYSCANCELDEAL,
                  GCONST.SYSCURRENTAC, SYSPACKINGCREDIT, SYSBUYERSCREDIT) THEN
      NUMERROR := FNCSETNODEVALUE(DOCNODE, TARGETNODE, VARTEMP);
    END IF;

    IF NUMACTION IN (GCONST.SYSMOVEDETAIL, GCONST.SYSADDDETAIL) THEN
      VARUSERID := FNCGETNODEVALUE(DOCNODE, '//UserCode');
      VARTERMINALID := FNCGETNODEVALUE(DOCNODE, '//TerminalID');
      VARENTITY := FNCGETNODEVALUE(DOCNODE, '//Entity');

      SELECT DECODE(PROCESSTYPE,
          GCONST.ADDSAVE, 'ADDSAVE',
          GCONST.EDITSAVE, 'EDITSAVE',
          GCONST.DELETESAVE, 'DELETESAVE',
          GCONST.CONFIRMSAVE, 'CONFIRMSAVE')
          INTO VARPROCESS
          FROM DUAL;

      NUMERROR := 5;
      VAROPERATION := 'Moving Details for ' || VARENTITY;
      DOCTEMP := XMLDOM.MAKEDOCUMENT(DOCNODE);

      IF NUMACTION = GCONST.SYSMOVEDETAIL THEN
        NODAUDIT := FNCADDNODE(DOCTEMP, TARGETNODE, 'AuditTrails', NULL);
      ELSE
        NLSTEMP := XMLDOM.GETELEMENTSBYTAGNAME(DOCTEMP, 'AuditTrails');

        IF (XMLDOM.GETLENGTH(NLSTEMP) = 0) THEN
          NODAUDIT := FNCADDNODE(DOCTEMP, TARGETNODE, 'AuditTrails', NULL);
        ELSE
          NODAUDIT := XMLDOM.ITEM(NLSTEMP, 0);
        END IF;

      END IF;

      NODROOT := FNCADDNODE(DOCTEMP, NODAUDIT, 'AuditTrail', NULL);
      NODTEMP := FNCADDNODE(DOCTEMP, NODROOT, 'Process', VARPROCESS);
      NODTEMP := FNCADDNODE(DOCTEMP, NODROOT, 'UserName', VARUSERID);
      NODTEMP := FNCADDNODE(DOCTEMP, NODROOT, 'TimeStamp', TO_CHAR(SYSTIMESTAMP, 'DD-MON-YYYY HH24:MI:SS:FF3'));
      NODTEMP := FNCADDNODE(DOCTEMP, NODROOT, 'TerminalName', VARTERMINALID);
      NODTEMP := FNCADDNODE(DOCTEMP, NODROOT, 'ProcessDate',TO_CHAR(SYSDATE, 'dd/mm/yyyy'));
    END IF;

    NUMERROR := 0;
    RETURN NUMERROR;
EXCEPTION
    WHEN BLANK_NODE THEN
      NUMERROR := -20101;
      VARERROR := 'Node: ' || VARNODE || ' does not exist or has no value';
      VARERROR := FNCRETURNERROR('ProcessNode', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
      RAISE_APPLICATION_ERROR(NUMERROR, VARERROR);
      RETURN NUMERROR;
    WHEN OTHERS THEN
        NUMERROR := SQLCODE;
        VARERROR := SQLERRM;
        VARERROR := FNCRETURNERROR('ProcessNode', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN NUMERROR;
END FNCPROCESSNODE;

FUNCTION FNCGENERATESERIAL
    ( SERIALTYPE IN NUMBER,
      COMPANYCODE IN NUMBER := 0)
    RETURN VARCHAR2
    IS
    NUMERROR            NUMBER;
    NUMSERIAL           NUMBER(10);
    NUMCONCAT           NUMBER(8);
    NUMRESET            NUMBER(8);
    NUMDATE             NUMBER(8);
    NUMWIDTH            NUMBER(1);
    NUMRESETMM          NUMBER(2);
    NUMRESETYY          NUMBER(2);
    NUMVALUEMM          NUMBER(2);
    NUMVALUEYY          NUMBER(2);
    NUMRETURNVALUE      NUMBER(15);
    DATRESET            DATE;
    DATVALUE            DATE;
    VARFLAG             VARCHAR2(1);
    VARFORMAT           VARCHAR2(25);
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    DATE_INCORRECT      EXCEPTION;
BEGIN
    VARMESSAGE := 'Generating serial number for ' || COMPANYCODE ||
                  PKGRETURNCURSOR.FNCGETDESCRIPTION(SERIALTYPE, GCONST.PICKUPLONG);
    NUMRETURNVALUE := 0;
    VARFORMAT := '';
    VAROPERATION := 'Extracting serial parameters';
    IF NVL(COMPANYCODE,0) = 0 THEN
      SELECT SERL_CONCAT_CODE, SERL_RESET_CODE, SERL_DATE_CODE,
        SERL_SERIAL_WIDTH, SERL_RESET_ON, SERL_SERIAL_NUMBER
        INTO NUMCONCAT, NUMRESET, NUMDATE,
        NUMWIDTH, DATRESET, NUMSERIAL
        FROM SERIALTABLE
        WHERE SERL_SERIAL_CODE = SERIALTYPE
        and serl_Record_status not in (10200005,10200006);
    ELSE
      SELECT SERL_CONCAT_CODE, SERL_RESET_CODE, SERL_DATE_CODE,
        SERL_SERIAL_WIDTH, SERL_RESET_ON, SERL_SERIAL_NUMBER
        INTO NUMCONCAT, NUMRESET, NUMDATE,
        NUMWIDTH, DATRESET, NUMSERIAL
        FROM SERIALTABLE
        WHERE decode(SERL_COMPANY_CODE,30199999,COMPANYCODE,SERL_COMPANY_CODE) = COMPANYCODE
        AND SERL_SERIAL_CODE = SERIALTYPE
        and serl_Record_status not in (10200005,10200006);
    END IF;
    IF NUMDATE = GCONST.OPTIONYES THEN
      IF NUMRESET = SRESETNEVER THEN
        DATVALUE := DATRESET;
      ELSE
        DATVALUE := SYSDATE;
      END IF;
    END IF;
    VAROPERATION := 'Extracting Date Reset';
    NUMRESETMM := TO_NUMBER(TO_CHAR(DATRESET, 'mm'));
    NUMRESETYY := TO_NUMBER(TO_CHAR(DATRESET, 'yy'));
    NUMVALUEMM := TO_NUMBER(TO_CHAR(DATVALUE, 'mm'));
    NUMVALUEYY := TO_NUMBER(TO_CHAR(DATVALUE, 'yy'));
    VARFLAG := 'N';

    IF TRUNC(DATVALUE,'dd') = TRUNC(DATRESET,'dd') THEN
      NUMSERIAL := NUMSERIAL + 1;
    ELSIF DATVALUE > DATRESET THEN 

      IF NUMRESET = GCONST.SRESETDAILY THEN
          NUMSERIAL := 1;
          VARFLAG := 'Y';
      ELSIF NUMRESET = GCONST.SRESETMONTHLY AND
          NUMRESETMM != NUMVALUEMM THEN
          NUMSERIAL := 1;
          VARFLAG := 'Y';
      ELSIF NUMRESET = GCONST.SRESETCALENDAR AND
          NUMRESETYY != NUMVALUEYY THEN
          NUMSERIAL := 1;
          VARFLAG := 'Y';
      ELSIF NUMRESET = GCONST.SRESETFINANCE THEN

          IF NUMRESETYY = NUMVALUEYY AND
                NUMRESETMM < 4 AND
                NUMVALUEMM > 3 THEN
            NUMSERIAL := 1;
            VARFLAG := 'Y';
          ELSIF NUMRESETYY != NUMVALUEYY AND
              NUMVALUEMM > 3 THEN
            NUMSERIAL := 1;
            VARFLAG := 'Y';
          END IF;
      END IF;
        IF VARFLAG = 'N' THEN
          NUMSERIAL := NUMSERIAL + 1;
        END IF;

        DATRESET := DATVALUE;
   ELSE                     
      RAISE DATE_INCORRECT;
    END IF;

    VAROPERATION := 'Generating serial number';
    IF NUMCONCAT = GCONST.SGENCONCATDAY THEN
      SELECT (TO_NUMBER(TO_CHAR(DATVALUE, 'yyyymmdd')) * POWER(10,NUMWIDTH))
        + NUMSERIAL
        INTO NUMRETURNVALUE
        FROM DUAL;
    ELSIF NUMCONCAT = GCONST.SGENCONCTMONTH THEN
      SELECT (TO_NUMBER(TO_CHAR(DATVALUE, 'yyyymm')) * POWER(10,NUMWIDTH))
        + NUMSERIAL
        INTO NUMRETURNVALUE
        FROM DUAL;
    ELSIF NUMCONCAT = GCONST.SGENCONCATYEAR THEN
      SELECT (TO_NUMBER(TO_CHAR(DATVALUE, 'yyyy')) * POWER(10,NUMWIDTH))
        + NUMSERIAL
        INTO NUMRETURNVALUE
        FROM DUAL;
    ELSIF NUMCONCAT = GCONST.SGENCONCATFIN THEN
      NUMVALUEMM := TO_NUMBER(TO_CHAR(DATVALUE, 'mm'));
      NUMVALUEYY := TO_NUMBER(TO_CHAR(DATVALUE, 'yy'));

      IF  TO_NUMBER(TO_CHAR(DATVALUE, 'mm')) > 3 THEN
        SELECT (TO_NUMBER(TO_CHAR(DATVALUE, 'yyyy') || TO_CHAR(DATVALUE, 'yy') + 1))
          * POWER(10,NUMWIDTH) + NUMSERIAL
          INTO NUMRETURNVALUE
          FROM DUAL;
      ELSE
       SELECT (TO_NUMBER(TO_CHAR(DATVALUE, 'yyyy') -1 || TO_CHAR(DATVALUE, 'yy')))
          * POWER(10,NUMWIDTH) + NUMSERIAL
          INTO NUMRETURNVALUE
          FROM DUAL;
      END IF;
   END IF;

    VAROPERATION := 'Updating serial number in database';
    IF NVL(COMPANYCODE,0) = 0 THEN
      UPDATE SERIALTABLE
        SET SERL_RESET_ON = DATRESET,
        SERL_SERIAL_NUMBER = NUMSERIAL
        WHERE SERL_SERIAL_CODE = SERIALTYPE
        and serl_Record_status not in (10200005,10200006);
    ELSE
      UPDATE SERIALTABLE
        SET SERL_RESET_ON = DATRESET,
        SERL_SERIAL_NUMBER = NUMSERIAL
        WHERE decode(SERL_COMPANY_CODE,30199999,COMPANYCODE,SERL_COMPANY_CODE) = COMPANYCODE
        AND SERL_SERIAL_CODE = SERIALTYPE
        and serl_Record_status not in (10200005,10200006);
    END IF;

    IF  NUMCONCAT = GCONST.SGENCONCATFIN THEN
      VARFORMAT := SUBSTR(TO_CHAR(NUMRETURNVALUE),7,NUMWIDTH) ||
          '/' || SUBSTR(TO_CHAR(NUMRETURNVALUE), 3,2) || '-' ||
          SUBSTR(TO_CHAR(NUMRETURNVALUE), 5,2);
   
    ELSIF NUMCONCAT = GCONST.SGENCONCATDAY THEN
      VARFORMAT := SUBSTR(TO_CHAR(NUMRETURNVALUE),1,8) ||
          '/' || SUBSTR(TO_CHAR(NUMRETURNVALUE),9,NUMWIDTH) ;
    ELSIF NUMRESET = SRESETNEVER   THEN
      VARFORMAT := LPAD(TO_CHAR(NUMSERIAL), NUMWIDTH,0);
    ELSE
      VARFORMAT := NUMRETURNVALUE;
    END IF;

    RETURN VARFORMAT;
EXCEPTION
    WHEN DATE_INCORRECT THEN
        NUMERROR := -20101;
        VARERROR := 'Date: ' || DATRESET || ' is greater than System Date: ' || DATVALUE;
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN NUMRETURNVALUE;
    WHEN OTHERS THEN
        NUMERROR := SQLCODE;
        VARERROR := SQLERRM;
        VARERROR := FNCRETURNERROR('GenSerial', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN NUMRETURNVALUE;
END FNCGENERATESERIAL;
FUNCTION FNCWRITETREE
      ( TREEROOT IN VARCHAR2,
        TREEXPATH IN VARCHAR2,
        DOCSOURCE IN XMLDOM.DOMDOCUMENT)
  RETURN XMLDOM.DOMDOCUMENT
    IS
    NUMERROR            NUMBER;
    NUMSUB              NUMBER;
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    DOCTARGET           GCONST.GDOCXML%TYPE;
    ELMTEMP             XMLDOM.DOMELEMENT;
    NODROOT             XMLDOM.DOMNODE;
    NODTARGET           XMLDOM.DOMNODE;
    NODSOURCE           XMLDOM.DOMNODE;
    NODTEMP             XMLDOM.DOMNODE;
    NLSTEMP             XMLDOM.DOMNODELIST;
    XMLTEMP             XMLTYPE;
BEGIN
    VARMESSAGE := 'Writing tree for: ' || TREEXPATH;

    VAROPERATION := 'Creating the source document';
    NODSOURCE := XMLDOM.MAKENODE(DOCSOURCE);

    VAROPERATION := 'Creating the target document';
    DOCTARGET := XMLDOM.NEWDOMDOCUMENT();
    NODROOT := XMLDOM.MAKENODE(DOCTARGET);
    ELMTEMP := XMLDOM.CREATEELEMENT(DOCTARGET,TREEROOT);
    NODTEMP := XMLDOM.MAKENODE(ELMTEMP);
    NODROOT := XMLDOM.APPENDCHILD(NODROOT, NODTEMP);

    NODTARGET := XSLPROCESSOR.SELECTSINGLENODE(NODROOT, '//' || TREEROOT);

    NLSTEMP := XSLPROCESSOR.SELECTNODES(NODSOURCE, TREEXPATH);

    VAROPERATION := 'Appending nodes from source to target';
    FOR NUMSUB IN 0..XMLDOM.GETLENGTH(NLSTEMP)-1
    LOOP
      NODTEMP := XMLDOM.ITEM(NLSTEMP, NUMSUB);
      NODTEMP := XMLDOM.IMPORTNODE(DOCTARGET, NODTEMP, TRUE);
      NODTEMP := XMLDOM.APPENDCHILD(NODTARGET, NODTEMP);
    END LOOP;

    RETURN DOCTARGET;
EXCEPTION
    WHEN OTHERS THEN
        NUMERROR := SQLCODE;
        VARERROR := SQLERRM;
        VARERROR := FNCRETURNERROR('WriteTree', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN DOCTARGET;

END FNCWRITETREE;


FUNCTION FNCXMLEXTRACT
    ( XMLSTRING IN XMLTYPE,
      NODENAME IN VARCHAR2,
      NODEVALUE IN VARCHAR2,
      INPUTTYPE IN NUMBER := 1)
    RETURN VARCHAR2
    IS
    NUMERROR            NUMBER;
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    VARVALUE            VARCHAR2(4000);
    VARTEMP             VARCHAR2(2000);
BEGIN
    VARVALUE := NULL;
    VARMESSAGE := 'Extracting value of ' || NODENAME;

    IF INPUTTYPE = GCONST.TYPENODENAME THEN
        VARTEMP := '//' || TRIM(NODENAME) || '/text()';
    ELSE
        VARTEMP := NODENAME || '/text()';
    END IF;

    VARVALUE := XMLSTRING.EXTRACT(VARTEMP).GETSTRINGVAL();

    RETURN TRIM(VARVALUE);
EXCEPTION
    WHEN OTHERS THEN
        NUMERROR := SQLCODE;
        VARERROR := SQLERRM;
        VARERROR := FNCRETURNERROR('XMLExtract(V)', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN VARVALUE;
END;

FUNCTION FNCXMLEXTRACT
    ( XMLSTRING IN XMLTYPE,
      NODENAME IN VARCHAR2,
      NODEVALUE IN NUMBER,
      INPUTTYPE IN NUMBER := 1)
      RETURN NUMBER
      IS
    NUMERROR            NUMBER;
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    NUMVALUE            NUMBER;
    VARTEMP             VARCHAR2(200);
BEGIN
    NUMVALUE := NULL;
    VARMESSAGE := 'Extracting value of ' || NODENAME;

    IF INPUTTYPE = GCONST.TYPENODENAME THEN
        VARTEMP := '//' || TRIM(NODENAME) || '/text()';
    ELSE
        VARTEMP := NODENAME || '/text()';
    END IF;

    NUMVALUE := XMLSTRING.EXTRACT(VARTEMP).GETNUMBERVAL();

    RETURN NUMVALUE;
EXCEPTION
    WHEN OTHERS THEN
        NUMERROR := SQLCODE;
        VARERROR := SQLERRM;
        VARERROR := FNCRETURNERROR('XMLExtract(N)', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN NUMVALUE;
END;

FUNCTION FNCXMLEXTRACT
    ( XMLSTRING IN XMLTYPE,
      NODENAME IN VARCHAR2,
      NODEVALUE IN DATE,
      INPUTTYPE IN NUMBER := 1)
    RETURN DATE
    IS

    NUMERROR            NUMBER;
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    DATVALUE            DATE;
    VARTEMP             VARCHAR2(200);
BEGIN
    DATVALUE := NULL;
    VARMESSAGE := 'Extracting value of ' || NODENAME;

    IF INPUTTYPE = GCONST.TYPENODENAME THEN
        VARTEMP := '//' || TRIM(NODENAME) || '/text()';
    ELSE
        VARTEMP := NODENAME || '/text()';
    END IF;
    begin
  --  insert into rtemp(TT,TT2) values('FNCXMLEXTRACT 1: ',XMLSTRING.EXTRACT(VARTEMP).GETSTRINGVAL());
         DATVALUE := TO_DATE(XMLSTRING.EXTRACT(VARTEMP).GETSTRINGVAL(), 'dd/mm/yyyy');
   --      insert into rtemp(TT,TT2) values('FNCXMLEXTRACT 2: ',DATVALUE);
    exception
        when others then
         DATVALUE := TO_DATE(XMLSTRING.EXTRACT(VARTEMP).GETSTRINGVAL(), 'mm/dd/yyyy');
  --        insert into rtemp(TT,TT2) values('FNCXMLEXTRACT 3: ',DATVALUE);
    end;

    IF DATVALUE IS NULL THEN
        VARTEMP := TRIM(SUBSTR(XMLSTRING.EXTRACT(VARTEMP).GETSTRINGVAL(),1,10));
        DATVALUE := TO_DATE(VARTEMP, 'yyyy-mm-dd');
    END IF;

    RETURN DATVALUE;
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -1861 THEN
            VARTEMP := TRIM(SUBSTR(XMLSTRING.EXTRACT(VARTEMP).GETSTRINGVAL(),1,10));
            DATVALUE := TO_DATE(VARTEMP, 'yyyy-mm-dd');
        ELSE
            DATVALUE := NULL;
        END IF;

        NUMERROR := SQLCODE;
        VARERROR := SQLERRM;
        VARERROR := FNCRETURNERROR('XMLExtract(D)', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN DATVALUE;
END;

FUNCTION FNCXMLEXTRACT
    ( XMLSTRING IN XMLTYPE,
      NODENAME IN VARCHAR2,
      NODEVALUE IN XMLTYPE,
      INPUTTYPE IN NUMBER := 1)
      RETURN XMLTYPE
      IS
    NUMERROR            NUMBER;
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    XMLTEMP             XMLTYPE;
    VARVALUE            VARCHAR2(4000);
    VARTEMP             VARCHAR2(200);
BEGIN
    VARVALUE := NULL;
    VARMESSAGE := 'Extracting value of ' || NODENAME;
    IF INPUTTYPE = GCONST.TYPENODENAME THEN
        VARTEMP := '//' || TRIM(NODENAME) || '/text()';
    ELSE
        VARTEMP := NODENAME || '/text()';
    END IF;

    VARVALUE := XMLSTRING.EXTRACT(VARTEMP).GETSTRINGVAL();

    RETURN XMLTYPE(VARVALUE);
EXCEPTION
    WHEN OTHERS THEN
        NUMERROR := SQLCODE;
        VARERROR := SQLERRM;
        VARERROR := FNCRETURNERROR('XMLExtract(X)', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
        RETURN XMLTYPE(VARVALUE);
END;

FUNCTION FNCADDNODE
        ( PARENTNODE IN XMLTYPE,
          CHILDNODE IN XMLTYPE,
          NODENAME IN VARCHAR2,
          CHILDTREE IN VARCHAR2 := NULL)
        RETURN XMLTYPE
    IS


    NUMERROR            NUMBER;
    NUMSUB              NUMBER;
    VARACLLIST          VARCHAR2(200);
    VARTEMP             VARCHAR2(15);
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    CURPICKUP           GCONST.DATACURSOR;
    DOCPARENT           XMLDOM.DOMDOCUMENT;
    DOCCHILD	        XMLDOM.DOMDOCUMENT;
    NLSXML              XMLDOM.DOMNODELIST;
    NODXML              XMLDOM.DOMNODE;
    NODNEW              XMLDOM.DOMNODE;
    CLBTEMP             CLOB;
BEGIN
    VARMESSAGE := 'Adding child node to parent ';

    NUMERROR := 1;

    VAROPERATION := 'Creating DOM documents ';
    DOCCHILD := XMLDOM.NEWDOMDOCUMENT(CHILDNODE); 
    DOCPARENT := XMLDOM.NEWDOMDOCUMENT(PARENTNODE); 

    VAROPERATION := 'Appending to parent ';
    NLSXML := XMLDOM.GETELEMENTSBYTAGNAME(DOCPARENT, NODENAME);
    NODNEW := XMLDOM.ITEM(NLSXML, 0);

    IF CHILDTREE IS NULL THEN
      NODXML := XMLDOM.MAKENODE(XMLDOM.GETDOCUMENTELEMENT(DOCCHILD));
      NODXML := XMLDOM.IMPORTNODE(DOCPARENT, NODXML, TRUE);
      NODNEW := XMLDOM.APPENDCHILD(NODNEW, NODXML);
    ELSE
      NLSXML := XMLDOM.GETELEMENTSBYTAGNAME(DOCCHILD, CHILDTREE);

      FOR NUMSUB IN 0..XMLDOM.GETLENGTH(NLSXML) -1
      LOOP
        NODXML := XMLDOM.ITEM(NLSXML, NUMSUB);
        NODXML := XMLDOM.IMPORTNODE(DOCPARENT, NODXML, TRUE);
        NODXML := XMLDOM.APPENDCHILD(NODNEW, NODXML);
      END LOOP;

    END IF;

    VAROPERATION := 'Writing the document to buffer' ;
    DBMS_LOB.CREATETEMPORARY (CLBTEMP,  TRUE);
    XMLDOM.WRITETOCLOB(DOCPARENT, CLBTEMP);

    RETURN XMLTYPE(CLBTEMP);
EXCEPTION
 WHEN OTHERS THEN
    NUMERROR := SQLCODE;
    VARERROR := SQLERRM;
    VARERROR := FNCRETURNERROR('AddNode', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
    RAISE_APPLICATION_ERROR(-20101, VARERROR);
    RETURN NULL;
END;
FUNCTION FNCGENERICGET
    ( QUERYSTRING IN VARCHAR2,
      ROWSETTAG IN VARCHAR2 := 'ROWSET',
      ROWTAG IN VARCHAR2 := 'ROW')

    RETURN XMLTYPE

        IS
    NUMERROR            NUMBER;
    NUMRECORDS          NUMBER(4);
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    QUERYCTX            DBMS_XMLGEN.CTXHANDLE;
    CLBDATA             CLOB;

BEGIN
    VARMESSAGE := 'Running dynamic query';

    INSERT INTO TEMP VALUES(QUERYSTRING,QUERYSTRING);
    COMMIT;
    QUERYCTX := DBMS_XMLGEN.NEWCONTEXT(QUERYSTRING);

    VAROPERATION := 'Setting Custom Tags';
    DBMS_XMLGEN.SETROWSETTAG(QUERYCTX, ROWSETTAG);
    DBMS_XMLGEN.SETROWTAG(QUERYCTX, ROWTAG);

    VAROPERATION := 'Extracting data in XML';
    CLBDATA := DBMS_XMLGEN.GETXML(QUERYCTX);
    NUMRECORDS := DBMS_XMLGEN.GETNUMROWSPROCESSED(QUERYCTX);
    DBMS_XMLGEN.CLOSECONTEXT(QUERYCTX);

    IF  NUMRECORDS = 0 THEN
      RAISE NO_DATA_FOUND;
    END IF;

    RETURN XMLTYPE(CLBDATA);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    NUMERROR := SQLCODE;
    VARERROR := 'No Data was found for the given query';
    VARERROR := FNCRETURNERROR('GenericGet', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
    RETURN NULL;
 WHEN OTHERS THEN
    NUMERROR := SQLCODE;
    VARERROR := SQLERRM;
    VARERROR := FNCRETURNERROR('GenericGet', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
    RAISE_APPLICATION_ERROR(-20101, VARERROR);
    RETURN NULL;
END;

FUNCTION FNCCREATEATTRIB
        (   DOCXML IN XMLDOM.DOMDOCUMENT,
            ATTRIBNAME IN VARCHAR2,
            ATTRIBVALUE IN VARCHAR2)
    RETURN XMLDOM.DOMNODE

    IS
    NUMERROR            NUMBER;
    VAROPERATION        GCONST.GVAROPERATION%TYPE;
    VARMESSAGE          GCONST.GVARMESSAGE%TYPE;
    VARERROR            GCONST.GVARERROR%TYPE;
    ATRTEMP		XMLDOM.DOMATTR;
    NODTEMP		XMLDOM.DOMNODE;
BEGIN
    VARMESSAGE := 'Creating attibute node: ' || ATTRIBNAME;

    VAROPERATION := 'Processing Attribute creation';
    ATRTEMP := XMLDOM.CREATEATTRIBUTE(DOCXML, ATTRIBNAME);
    XMLDOM.SETVALUE(ATRTEMP, ATTRIBVALUE);
    NODTEMP := XMLDOM.MAKENODE(ATRTEMP);

    RETURN NODTEMP;
EXCEPTION
 WHEN OTHERS THEN
    NUMERROR := SQLCODE;
    VARERROR := SQLERRM;
    VARERROR := FNCRETURNERROR('CreateAttrib', NUMERROR, VARMESSAGE,
                        VAROPERATION, VARERROR);
    RAISE_APPLICATION_ERROR(-20101, VARERROR);
    RETURN NULL;
END FNCCREATEATTRIB;

FUNCTION FNCRETURNDOMDOC (BUF IN VARCHAR2)
    RETURN XMLDOM.DOMDOCUMENT

IS
  XP XMLPARSER.PARSER;
  DC XMLDOM.DOMDOCUMENT;
BEGIN
  XP := XMLPARSER.NEWPARSER;
  XMLPARSER.PARSEBUFFER(XP, BUF);
  DC := XMLPARSER.GETDOCUMENT(XP);
  XMLPARSER.FREEPARSER(XP);
  RETURN(DC);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;

FUNCTION FNCRETURNPARAM(CLBPARAM IN CLOB, VARNODE IN VARCHAR2)
  RETURN VARCHAR2

IS
  DOCXML XMLDOM.DOMDOCUMENT;
  NOLXML XMLDOM.DOMNODELIST;
  NODXML XMLDOM.DOMNODE;
  VARERROR VARCHAR2(256);
  VARVALUE VARCHAR2(5000);
  INVALID_PARAM EXCEPTION;
BEGIN
    DOCXML := FNCRETURNDOMDOC(CLBPARAM);
 --   insert into rtemp(TT,TT2,TT3) values ('Inside FNCRETURNPARAM 0','VARNODE: '||VARNODE, CLBPARAM);commit;
    
 	NOLXML := XMLDOM.GETELEMENTSBYTAGNAME(DOCXML,  VARNODE);

 	IF  XMLDOM.GETLENGTH(NOLXML) = 0 THEN
        VARVALUE := NULL;
 	ELSE
        NODXML := XMLDOM.ITEM(NOLXML, 0);
        NODXML := XMLDOM.GETFIRSTCHILD(NODXML);
        VARVALUE := XMLDOM.GETNODEVALUE(NODXML);
    END IF;

    IF VARVALUE IS NULL THEN
        RAISE INVALID_PARAM;
    END IF;

  XMLDOM.FREEDOCUMENT(DOCXML);

  RETURN(VARVALUE);
EXCEPTION
  WHEN INVALID_PARAM THEN
    XMLDOM.FREEDOCUMENT(DOCXML);
    VARERROR := 'ReturnParam: Unable to extract Parameter : ' || VARNODE;
    RAISE_APPLICATION_ERROR(-20101, VARERROR);
	WHEN XMLDOM.INDEX_SIZE_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'Index Size error');
	WHEN XMLDOM.DOMSTRING_SIZE_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'String Size error');
	WHEN XMLDOM.HIERARCHY_REQUEST_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'Hierarchy request error');
	WHEN XMLDOM.WRONG_DOCUMENT_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'Wrong doc error');
	WHEN XMLDOM.INVALID_CHARACTER_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'Invalid Char error');
	WHEN XMLDOM.NO_DATA_ALLOWED_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'Nod data allowed error');
	WHEN XMLDOM.NO_MODIFICATION_ALLOWED_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'No mod allowed error');
	WHEN XMLDOM.NOT_FOUND_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'Not found error');
	WHEN XMLDOM.NOT_SUPPORTED_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'Not supported error');
	WHEN XMLDOM.INUSE_ATTRIBUTE_ERR THEN
	RAISE_APPLICATION_ERROR(-20120, 'In use attr error');
  WHEN OTHERS THEN
    VARERROR := 'ReturnParam: XML Error - node or value does not exist : ' || VARNODE;
    RAISE_APPLICATION_ERROR(SQLCODE, VARERROR);
END;

FUNCTION FNCRETURNPARAM(DOCXML IN XMLDOM.DOMDOCUMENT, VARNODE IN VARCHAR2)
  RETURN VARCHAR2

IS
  NOLXML XMLDOM.DOMNODELIST;
  NODXML XMLDOM.DOMNODE;
  VARERROR VARCHAR2(512);
  VARVALUE VARCHAR2(5000);
  INVALID_PARAM EXCEPTION;
BEGIN
    VARVALUE := NULL;
    NOLXML := XMLDOM.GETELEMENTSBYTAGNAME(DOCXML,  VARNODE);

 	IF  XMLDOM.GETLENGTH(NOLXML) = 0 THEN
        RAISE NO_DATA_FOUND;
 	ELSE
        NODXML := XMLDOM.ITEM(NOLXML, 0);
        NODXML := XMLDOM.GETFIRSTCHILD(NODXML);

        IF XMLDOM.ISNULL(NODXML) = TRUE  THEN
            VARVALUE := NULL;
        ELSE
            VARVALUE := XMLDOM.GETNODEVALUE(NODXML);
        END IF;

    END IF;

  RETURN(VARVALUE);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN NULL;
    WHEN INVALID_PARAM THEN
        VARERROR := 'ReturnParam1: Unable to extract Parameter : ' || VARNODE;
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
    WHEN OTHERS THEN
        VARERROR := 'ReturnParam1: ' || VARNODE || ' - ' || SQLERRM;
        RAISE_APPLICATION_ERROR(-20101, VARERROR);
END;

PROCEDURE PRCGENERICINSERT
        ( PARAMDATA IN CLOB,
          ERRORDATA OUT NOCOPY CLOB,
          PROCESSDATA OUT NOCOPY CLOB)

IS
   NUMERROR               NUMBER;
  NUMRECORDS              NUMBER;
  NUMRECORDSETS           NUMBER(1);
  VARNODE                 VARCHAR2(35);
  VARVALUE                VARCHAR2(4000);
  VAROPERATION            GCONST.GVAROPERATION%TYPE;
  VARMESSAGE              GCONST.GVARMESSAGE%TYPE;
  VARERROR                GCONST.GVARERROR%TYPE;
  DOCXML                  XMLDOM.DOMDOCUMENT;
  NLSXML                  XMLDOM.DOMNODELIST;
  NODXML                  XMLDOM.DOMNODE;
  INSCTX                  DBMS_XMLSAVE.CTXTYPE;
BEGIN
  NUMERROR := 1;
  VAROPERATION := 'Creating XML Document';
  DOCXML := XMLDOM.NEWDOMDOCUMENT(XMLTYPE(PARAMDATA));
  VAROPERATION := 'Extracting entity information';
  VARVALUE := GCONST.FNCXMLEXTRACT(XMLTYPE(PARAMDATA), 'Entity',VARVALUE);

  VARMESSAGE := 'Inserting Records to ' || VARVALUE;

  VAROPERATION := 'Preparing context for insert';
  INSCTX := DBMS_XMLSAVE.NEWCONTEXT(VARVALUE);
  DBMS_XMLSAVE.CLEARUPDATECOLUMNLIST(INSCTX);


  NLSXML := XMLDOM.GETELEMENTSBYTAGNAME(DOCXML,  'ROW');
  NODXML := XMLDOM.ITEM(NLSXML, 0);
  NLSXML := XMLDOM.GETCHILDNODES(NODXML);

  FOR I IN 0..XMLDOM.GETLENGTH(NLSXML)-1 LOOP
    NODXML := XMLDOM.ITEM(NLSXML,I);
    VARNODE := XMLDOM.GETNODENAME(NODXML);

      DBMS_XMLSAVE.SETUPDATECOLUMN(INSCTX, VARNODE);
  END LOOP;


  VAROPERATION := 'Setting date format for XML';

  DBMS_XMLSAVE.SETDATEFORMAT(INSCTX, 'dd/MM/yyyy');

  VAROPERATION := 'Inserting row set';
  NUMRECORDS := DBMS_XMLSAVE.INSERTXML(INSCTX, PARAMDATA);
  DBMS_XMLSAVE.CLOSECONTEXT(INSCTX);
  NUMERROR := 0;
  VARERROR := 'Successful Operation';
  PROCESSDATA := PARAMDATA;
  ERRORDATA := FNCRETURNERROR('GenericInsert',VARMESSAGE, 0, NUMERROR,VAROPERATION,VARERROR);
EXCEPTION
   WHEN OTHERS THEN
    NUMERROR := SQLCODE;
    VARERROR := SQLERRM;
    ERRORDATA := FNCRETURNERROR('GenericInsert',VARMESSAGE, 0, NUMERROR,VAROPERATION,VARERROR);
END PRCGENERICINSERT;


PROCEDURE PRCGENERICEDIT
        ( PARAMDATA IN CLOB,
          ERRORDATA OUT NOCOPY CLOB,
          PROCESSDATA OUT NOCOPY CLOB)

IS
  NUMERROR                NUMBER;
  NUMRECORDS              NUMBER;
  NUMRECORDSETS           NUMBER(1);
  VARNODE                 VARCHAR2(35);
  VARVALUE                VARCHAR2(35);
  VAROPERATION            GCONST.GVAROPERATION%TYPE;
  VARMESSAGE              GCONST.GVARMESSAGE%TYPE;
  VARERROR                GCONST.GVARERROR%TYPE;
  DOCXML                  XMLDOM.DOMDOCUMENT;
  NLSXML                  XMLDOM.DOMNODELIST;
  NODXML                  XMLDOM.DOMNODE;
  INSCTX                  DBMS_XMLSAVE.CTXTYPE;
BEGIN
  NUMERROR := 1;

  VAROPERATION := 'Creating XML Document';
  DOCXML := XMLDOM.NEWDOMDOCUMENT(XMLTYPE(PARAMDATA));

  VAROPERATION := 'Extracting entity information';
  VARVALUE := GCONST.FNCXMLEXTRACT(XMLTYPE(PARAMDATA), 'Entity', VARVALUE);

  VARMESSAGE := 'Editing Records of ' || VARVALUE;

  VAROPERATION := 'Preparing context for insert';
  INSCTX := DBMS_XMLSAVE.NEWCONTEXT(VARVALUE);
  DBMS_XMLSAVE.CLEARUPDATECOLUMNLIST(INSCTX);


  NLSXML := XMLDOM.GETELEMENTSBYTAGNAME(DOCXML,  'ROW');
  NODXML := XMLDOM.ITEM(NLSXML, 0);
  NLSXML := XMLDOM.GETCHILDNODES(NODXML);

  FOR I IN 0..XMLDOM.GETLENGTH(NLSXML)-1 LOOP
    NODXML := XMLDOM.ITEM(NLSXML,I);
    VARNODE := XMLDOM.GETNODENAME(NODXML);
    DBMS_XMLSAVE.SETUPDATECOLUMN(INSCTX, VARNODE);
  END LOOP;


  VAROPERATION := 'Setting date format for XML';
  DBMS_XMLSAVE.SETDATEFORMAT(INSCTX, 'dd/MM/yyyy');
  VAROPERATION := 'Updating the row set';
  NUMRECORDS := DBMS_XMLSAVE.UPDATEXML(INSCTX, PARAMDATA);
  DBMS_XMLSAVE.CLOSECONTEXT(INSCTX);
  NUMERROR := 0;
  VARERROR := 'Successful Operation';
  ERRORDATA := FNCRETURNERROR('GenericEdit',VARMESSAGE, 0, NUMERROR,VAROPERATION,VARERROR);
EXCEPTION
   WHEN OTHERS THEN
    NUMERROR := SQLCODE;
    VARERROR := SQLERRM;
    ERRORDATA := FNCRETURNERROR('GenericInsert',VARMESSAGE, 0, NUMERROR,VAROPERATION,VARERROR);
END PRCGENERICEDIT;

BEGIN
    SELECT PICK_KEY_VALUE
        INTO GNUMCOMPANYCODE
        FROM TRMASTER001
        WHERE PICK_KEY_VALUE = 30100001;
EXCEPTION
    WHEN OTHERS THEN
        GVARERROR := SQLERRM;
        RAISE_APPLICATION_ERROR(-20101, GVARERROR);

END PKGGLOBALMETHODS;
/